Project Structure:
./setup.sh
./requirements.txt
./Dockerfile
./docker-compose.yml
./manage.py
prototype/asgi.py
prototype/settings.py
prototype/urls.py
prototype/wsgi.py
prototype/telegram_bot/models.py
prototype/telegram_bot/apps.py
prototype/telegram_bot/admin.py
prototype/telegram_bot/urls.py
prototype/telegram_bot/views.py
prototype/telegram_bot/management/commands/run_bot.py
prototype/helpers/openai_helper.py

File Contents:
setup.sh:
```
#!/bin/bash

# 1) Create Django project if it doesn't exist yet
#    (If you already have the `prototype` folder with settings.py, you can skip startproject.)
if [ ! -d "prototype" ]; then
    docker run --rm -v "$(pwd)":/app -w /app python:3.10 \
      bash -c "pip install django==4.2.2 && django-admin startproject prototype ."
fi

# 2) Make sure you have an __init__.py, just in case
touch prototype/__init__.py

# 3) Create helpers folder and move openai_helper.py into it if it exists
mkdir -p prototype/helpers
if [ -f "openai_helper.py" ]; then
    mv openai_helper.py prototype/helpers/
fi

# 4) Build & run containers
docker-compose build --no-cache
docker-compose up -d

```

requirements.txt:
```
Django==4.2.2
openai==1.3.0
python-telegram-bot==20.6
python-dotenv==0.19.2
```

Dockerfile:
```
FROM python:3.10
WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy all local files to /app
COPY . .

# Ensure proper permissions
RUN chmod +x manage.py
RUN chmod -R 755 .

EXPOSE 9009
CMD ["python", "manage.py", "runserver", "0.0.0.0:9009"]
```

docker-compose.yml:
```
version: '3'
services:
  web:
    build: .
    ports:
      - "9009:9009"
    volumes:
      - .:/app
```

manage.py:
```
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'prototype.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

```

asgi.py:
```
"""
ASGI config for prototype project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'prototype.settings')

application = get_asgi_application()

```

settings.py:
```
"""
Django settings for prototype project.

Generated by 'django-admin startproject' using Django 4.2.2.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
import os
from dotenv import load_dotenv  # Added import

# Load environment variables from .env file
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-*%wmhz#xwt6(m%aj4&ce=&&-v1m(koozn0wt6gjo^p+x@alujz'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'prototype.telegram_bot',  # Updated to use full path
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'prototype.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'prototype.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Added Telegram Bot Token
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
```

urls.py:
```
"""
URL configuration for prototype project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path

urlpatterns = [
    path('admin/', admin.site.urls),
]

```

wsgi.py:
```
"""
WSGI config for prototype project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'prototype.settings')

application = get_wsgi_application()

```

models.py:
```
from django.db import models

class Task(models.Model):
    TASK_TYPES = [
        ('self_help', 'Self-help Coach'),
        ('text_task', 'Text Task'),
        ('mindfulness', 'Mindfulness and Gratitude'),
        ('brain_train', 'Brain-train'),
    ]

    user_id = models.IntegerField()
    task_type = models.CharField(max_length=20, choices=TASK_TYPES)
    task_content = models.TextField()
    user_response = models.TextField(null=True, blank=True)
    is_correct = models.BooleanField(null=True, blank=True)
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user_id} - {self.task_type} - {self.timestamp}"

```

apps.py:
```
from django.apps import AppConfig

class TelegramBotConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'prototype.telegram_bot'  # Updated to use full path

```

admin.py:
```
from django.contrib import admin
from .models import Task

admin.site.register(Task)

```

urls.py:
```
from django.urls import path

urlpatterns = [
    # Define your URLs here
]

```

views.py:
```
from django.shortcuts import render

# Create your views here.

```

run_bot.py:
```
import logging
from django.core.management.base import BaseCommand
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
    MessageHandler,
    filters,
)
from django.conf import settings
from prototype.helpers.openai_helper import send_prompt_to_openai
from prototype.telegram_bot.models import Task
from asgiref.sync import sync_to_async

# Configure logging to output to console
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = 'Run the Telegram bot'

    # Synchronous helper functions
    def get_last_tasks_sync(self, user_id):
        return list(Task.objects.filter(user_id=user_id).order_by('-timestamp')[:5])

    def create_task_sync(self, user_id, task_type, task_content, user_response=None, is_correct=None):
        return Task.objects.create(
            user_id=user_id,
            task_type=task_type,
            task_content=task_content,
            user_response=user_response,
            is_correct=is_correct
        )

    def get_latest_text_task_sync(self, user_id):
        return Task.objects.filter(user_id=user_id, task_type='text_task').order_by('-timestamp').first()

    def get_latest_brain_train_sync(self, user_id):
        return Task.objects.filter(user_id=user_id, task_type='brain_train').order_by('-timestamp').first()

    def save_task_sync(self, task):
        task.save()

    # Use this to GENERATE new content/prompts
    def generate_content_sync(self, system_content, user_prompt):
        return send_prompt_to_openai(system_content, user_prompt)

    # Use this to EVALUATE user's response
    def evaluate_response_sync(self, system_content, user_prompt):
        return send_prompt_to_openai(system_content, user_prompt)

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            user = update.effective_user
            logger.info(f"User {user.first_name} started the bot.")

            keyboard = [
                [
                    InlineKeyboardButton("ðŸ’¡ Self-help Coach", callback_data='self_help'),
                    InlineKeyboardButton("âœï¸ Text Task", callback_data='text_task'),
                ],
                [
                    InlineKeyboardButton("ðŸ§˜ Mindfulness & Gratitude", callback_data='mindfulness'),
                    InlineKeyboardButton("ðŸ§© Brain-train", callback_data='brain_train'),
                ],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.message.reply_text(
                f"Hello {user.first_name}! How can I assist you today?",
                reply_markup=reply_markup
            )
            logger.info("Sent greeting message with options.")
        except Exception as e:
            logger.error(f"Error in start handler: {e}")

    async def button(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            query = update.callback_query
            await query.answer()
            user = query.from_user
            task_type = query.data

            logger.info(f"User {user.first_name} selected {task_type}.")

            # Fetch last 5 tasks
            last_tasks = await sync_to_async(self.get_last_tasks_sync)(user.id)
            last_prompts = "\n".join([f"{task.task_type}: {task.task_content}" for task in last_tasks])

            # Prepare general keyboard for after we respond
            keyboard = [
                [
                    InlineKeyboardButton("ðŸ’¡ Self-help Coach", callback_data='self_help'),
                    InlineKeyboardButton("âœï¸ Text Task", callback_data='text_task'),
                ],
                [
                    InlineKeyboardButton("ðŸ§˜ Mindfulness & Gratitude", callback_data='mindfulness'),
                    InlineKeyboardButton("ðŸ§© Brain-train", callback_data='brain_train'),
                ],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            if task_type == 'self_help':
                system = (
                    "You are a self-help coach. Provide a short, fresh tip on self-improvement. "
                    f"Last 5 tasks:\n{last_prompts}\n"
                    "Do not repeat or closely resemble previous tips. Keep it under 40 words."
                )
                user_prompt = "Generate a new short self-help tip."
                response = await sync_to_async(self.generate_content_sync)(system, user_prompt)
                task_content = response or "Here is your self-help tip."
                await sync_to_async(self.create_task_sync)(user.id, 'self_help', task_content)
                await query.message.reply_text(task_content)
                logger.info("Sent Self-help Coach tip.")

            elif task_type == 'text_task':
                system = (
                    "You are a productivity assistant. Provide a short writing task for self-improvement. "
                    f"Last 5 tasks:\n{last_prompts}\n"
                    "Do not repeat or closely resemble previous tasks. Keep it under 50 words."
                )
                user_prompt = "Generate a new text task for the user."
                response = await sync_to_async(self.generate_content_sync)(system, user_prompt)
                task_content = response or "Write about your goals for this week."
                await sync_to_async(self.create_task_sync)(user.id, 'text_task', task_content)
                await query.message.reply_text(task_content)
                logger.info("Sent Text Task.")
                context.user_data['awaiting_response'] = 'text_task'

            elif task_type == 'mindfulness':
                system = (
                    "You are a mindfulness coach. Provide a short mindfulness or gratitude exercise. "
                    f"Last 5 tasks:\n{last_prompts}\n"
                    "Do not repeat or closely resemble previous tasks."
                )
                user_prompt = "Generate a new mindfulness/gratitude exercise."
                response = await sync_to_async(self.generate_content_sync)(system, user_prompt)
                task_content = response or "Take a 5-minute meditation break and note three things you're grateful for."
                await sync_to_async(self.create_task_sync)(user.id, 'mindfulness', task_content)
                await query.message.reply_text(task_content)
                logger.info("Sent Mindfulness and Gratitude task.")

            elif task_type == 'brain_train':
                system = (
                    "You are a brain trainer providing a single short puzzle or quiz question. "
                    f"Last 5 tasks:\n{last_prompts}\n"
                    "Do not repeat or closely resemble previous puzzles."
                )
                user_prompt = "Generate a new one-question puzzle or quiz."
                response = await sync_to_async(self.generate_content_sync)(system, user_prompt)
                task_content = response or "What has keys but can't open locks?"
                await sync_to_async(self.create_task_sync)(user.id, 'brain_train', task_content)
                await query.message.reply_text(task_content)
                logger.info("Sent Brain-train puzzle.")
                context.user_data['awaiting_response'] = 'brain_train'

            await query.message.reply_text("What do you want to do next?", reply_markup=reply_markup)
            logger.info("Displayed options again to the user.")
        except Exception as e:
            logger.error(f"Error in button handler: {e}")

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            user = update.effective_user
            text = update.message.text
            awaiting = context.user_data.get('awaiting_response')

            # Evaluate user responses if they are in the middle of a text_task
            if awaiting == 'text_task':
                logger.info(f"Received user response for Text Task from {user.first_name}: {text}")
                task = await sync_to_async(self.get_latest_text_task_sync)(user.id)
                if task:
                    last_tasks = await sync_to_async(self.get_last_tasks_sync)(user.id)
                    last_prompts = "\n".join([f"{t.task_type}: {t.task_content}" for t in last_tasks])
                    system = (
                        "You are an assistant evaluating a user's written text. "
                        "Provide short, constructive feedback on self-improvement. "
                        f"Previous tasks:\n{last_prompts}\n"
                        "Do not repeat or be overly verbose."
                    )
                    user_prompt = f"User's text:\n{text}\nEvaluate and give feedback."
                    response = await sync_to_async(self.evaluate_response_sync)(system, user_prompt)
                    task.user_response = text
                    task.is_correct = True  # or any custom logic
                    await sync_to_async(self.save_task_sync)(task)
                    await update.message.reply_text(response or "Your response has been evaluated.")
                    logger.info("Evaluated user response for Text Task.")
                context.user_data['awaiting_response'] = None

            # Evaluate user responses if they are in the middle of a brain_train
            elif awaiting == 'brain_train':
                logger.info(f"Received user response for Brain-train from {user.first_name}: {text}")
                task = await sync_to_async(self.get_latest_brain_train_sync)(user.id)
                if task:
                    last_tasks = await sync_to_async(self.get_last_tasks_sync)(user.id)
                    last_prompts = "\n".join([f"{t.task_type}: {t.task_content}" for t in last_tasks])
                    system = (
                        "You are an assistant evaluating a short puzzle or quiz response. "
                        "Provide brief validation or correction. "
                        f"Previous tasks:\n{last_prompts}\n"
                        "Do not repeat yourself or be overly verbose."
                    )
                    user_prompt = f"Puzzle was: {task.task_content}\nUser's answer: {text}\nEvaluate correctness."
                    response = await sync_to_async(self.evaluate_response_sync)(system, user_prompt)
                    task.user_response = text
                    # You could parse the response to decide is_correct; here we assume True
                    task.is_correct = True
                    await sync_to_async(self.save_task_sync)(task)
                    await update.message.reply_text(response or "Your puzzle answer has been evaluated.")
                    logger.info("Evaluated user response for Brain-train.")
                context.user_data['awaiting_response'] = None

            else:
                logger.info(f"Received message from {user.first_name}: {text} (No action taken)")

            # After handling or ignoring, show main buttons again
            keyboard = [
                [
                    InlineKeyboardButton("ðŸ’¡ Self-help Coach", callback_data='self_help'),
                    InlineKeyboardButton("âœï¸ Text Task", callback_data='text_task'),
                ],
                [
                    InlineKeyboardButton("ðŸ§˜ Mindfulness & Gratitude", callback_data='mindfulness'),
                    InlineKeyboardButton("ðŸ§© Brain-train", callback_data='brain_train'),
                ],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text("What do you want to do next?", reply_markup=reply_markup)
            logger.info("Displayed options again to the user after handling message.")
        except Exception as e:
            logger.error(f"Error in handle_message handler: {e}")

    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Log the error and send a message to notify the user."""
        logger.error(msg="Exception while handling an update:", exc_info=context.error)
        # Notify the user about the error
        if isinstance(update, Update) and update.effective_message:
            await update.effective_message.reply_text("An unexpected error occurred. Please try again later.")

    def handle(self, *args, **kwargs):
        token = settings.TELEGRAM_BOT_TOKEN
        if not token:
            logger.error("TELEGRAM_BOT_TOKEN is not set in environment variables.")
            return

        application = ApplicationBuilder().token(token).build()

        # Register handlers
        start_handler = CommandHandler('start', self.start)
        button_handler = CallbackQueryHandler(self.button)
        message_handler = MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message)

        application.add_handler(start_handler)
        application.add_handler(button_handler)
        application.add_handler(message_handler)

        # Register error handler
        application.add_error_handler(self.error_handler)

        logger.info("Starting Telegram bot polling.")
        application.run_polling()
        logger.info("Telegram bot stopped.")

```

openai_helper.py:
```
import logging
import json
from django.conf import settings
from openai import OpenAI

logger = logging.getLogger(__name__)

def send_prompt_to_openai(
    system_content: str,
    user_prompt: str,
    model: str = "gpt-4o-mini",
    max_tokens: int = 1000,
    temperature: float = 0.7,
):
    """
    Sends a prompt to the OpenAI Chat Completion endpoint using the same style
    of request your code already uses. Returns the content string or None on error.
    """
    try:
        # Create the OpenAI client with the existing approach
        client = OpenAI(api_key=settings.OPENAI_API_KEY)
        
        # Make the chat completion request
        chat_completion = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": system_content},
                {"role": "user", "content": user_prompt}
            ],
            max_tokens=max_tokens,
            temperature=temperature
        )
        
        if not chat_completion.choices:
            logger.error("No completion choices returned by OpenAI.")
            return None
        
        response_content = chat_completion.choices[0].message.content.strip()
        logger.debug(f"Raw response from OpenAI: {repr(response_content)}")
        
        return response_content
    
    except Exception as e:
        logger.error(f"Error calling OpenAI: {str(e)}")
        return None

def parse_json_response(response_content: str) -> dict:
    """
    Attempts to parse a string `response_content` as JSON.
    Returns a Python dict on success, or None on failure.
    """
    try:
        # In case the model includes ```json ... ```, remove those
        cleaned = response_content.replace("```json", "").replace("```", "").strip()
        data = json.loads(cleaned)
        return data
    except json.JSONDecodeError as e:
        logger.error(f"JSON parse error: {e}")
        return None

```
